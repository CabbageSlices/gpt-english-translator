cleanup and refactor the following code to follow good programming principles. Imagine you are an experienced software developer and you need to turn the given code into something easily manageable. The resulting code should be clean, robust, and contain all other properties of good code.

<!DOCTYPE html>
<html>

<head>
  <title>ChatGPT English Translator</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    #input {
      width: 100%;
      height: 50px;
      font-size: 16px;
      padding: 10px;
      box-sizing: border-box;
      border: 2px solid #ccc;
      border-radius: 4px;
      margin-bottom: 10px;
    }

    #output {
      display: flex;
      flex-wrap: wrap;
    }

    .input-chunk,
    .output-chunk {
      width: 50%;
      padding: 10px;
      box-sizing: border-box;
      white-space: pre-wrap;
      border: 1px solid red;
      margin-bottom: 10px;
    }

    .input-chunk {
      background-color: #f2f2f2;
      border-top: 1px solid green;
    }

    button {
      background-color: #4CAF50;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #45a049;
    }
    #final-output {      
      white-space: pre-wrap;
    }
  </style>
</head>
<script>
  function splitText(text) {
    const replaced = text.replace(/\r\n/g, ".\n\n");
    const paragraphs = replaced.split(/.\n\n/);
    const chunks = [];
    let chunk = '';
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph = paragraphs[i];
      if (chunk.length + paragraph.length > 850) {
        chunks.push(chunk);
        chunk = '';
      }
      chunk += paragraph + '\n\n';
    }
    if (chunk.trim().length > 1) {
      chunks.push(chunk);
    }
    return chunks;
  }
  function translateChunk(chunk) {
    return new Promise((resolve, reject) => {
      const url = "https://api.openai.com/v1/chat/completions";
      const data = JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [{"role": "user", "content": "translate to English: " + chunk}]
      });
      const xhr = new XMLHttpRequest();
      xhr.addEventListener("readystatechange", function () {
        if (this.readyState === this.DONE) {
          const response = JSON.parse(this.responseText);
          const output = response.choices[0].message.content;
          resolve(output);
        }
      });
      xhr.open("POST", url);
      xhr.setRequestHeader("Content-Type", "application/json");
      xhr.setRequestHeader("Authorization", "Bearer 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");
      xhr.send(data);
    });
  }
  async function translateAll() {
    const input = document.getElementById("input").value;
    const chunks = splitText(input);
    const outputContainer = document.getElementById("output");
    const finalOutputContainer = document.getElementById("final-output");
    outputContainer.innerHTML = '';
    finalOutputContainer.innerHTML = '';
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      const inputChunkElement = document.createElement('div');
      inputChunkElement.className = 'input-chunk';
      inputChunkElement.innerHTML = '<p>' + chunk + '</p>';
      outputContainer.appendChild(inputChunkElement);
      const outputChunkElement = document.createElement('div');
      outputChunkElement.className = 'output-chunk';
      let output
      try {
        output = await translateChunk(chunk);
        console.log(output)
        outputChunkElement.innerHTML = '<p>' + output + '</p>';
      } catch (error) {
        outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
      }
      outputContainer.appendChild(outputChunkElement);
      finalOutputContainer.innerHTML += output + '\n';
      await setTimeout(() => {console.log("finished waiting for delay.")}, 3000)
    }
  }
</script>

<body>
  <h1>ChatGPT English Translator</h1>
  <label for="input">Input Text:</label>
  <br>
  <textarea id="input" name="input"></textarea>
  <br>
  <button onclick="translateAll()">Translate</button>
  <br>
  <h2>Translated Chunks:</h2>
  <div id="output"></div>
  <h2>Final Translated Output:</h2>
  <div id="final-output"></div>
</body>

</html>
--------------------------
I have refactored the code, separating the HTML, CSS, and JavaScript files. The code is now more maintainable and easier to understand.

index.html:

html
Copy code
<!DOCTYPE html>
<html>

<head>
  <title>ChatGPT English Translator</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <script src="translator.js" defer></script>
</head>

<body>
  <h1>ChatGPT English Translator</h1>
  <label for="input">Input Text:</label>
  <br>
  <textarea id="input" name="input"></textarea>
  <br>
  <button id="translate-button">Translate</button>
  <br>
  <h2>Translated Chunks:</h2>
  <div id="output"></div>
  <h2>Final Translated Output:</h2>
  <div id="final-output"></div>
</body>

</html>


styles.css:

css
Copy code
body {
  font-family: Arial, sans-serif;
}

#input {
  width: 100%;
  height: 50px;
  font-size: 16px;
  padding: 10px;
  box-sizing: border-box;
  border: 2px solid #ccc;
  border-radius: 4px;
  margin-bottom: 10px;
}

#output {
  display: flex;
  flex-wrap: wrap;
}

.input-chunk,
.output-chunk {
  width: 50%;
  padding: 10px;
  box-sizing: border-box;
  white-space: pre-wrap;
  border: 1px solid red;
  margin-bottom: 10px;
}

.input-chunk {
  background-color: #f2f2f2;
  border-top: 1px solid green;
}

button {
  background-color: #4CAF50;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background-color: #45a049;
}

#final-output {
  white-space: pre-wrap;
}


translator.js:

javascript
Copy code
document.getElementById("translate-button").addEventListener("click", translateAll);

function splitText(text) {
  const replaced = text.replace(/\r\n/g, ".\n\n");
  const paragraphs = replaced.split(/.\n\n/);
  const chunks = [];
  let chunk = '';

  paragraphs.forEach(paragraph => {
    if (chunk.length + paragraph.length > 850) {
      chunks.push(chunk);
      chunk = '';
    }
    chunk += paragraph + '\n\n';
  });

  if (chunk.trim().length > 1) {
    chunks.push(chunk);
  }

  return chunks;
}

function translateChunk(chunk) {
  return new Promise((resolve, reject) => {
    const url = "https://api.openai.com/v1/chat/completions";
    const data = JSON.stringify({
      model: "gpt-3.5-turbo",
      messages: [{ "role": "user", "content": "translate to English: " + chunk }]
    });
    const xhr = new XMLHttpRequest();

    xhr.addEventListener("readystatechange", function () {
      if (this.readyState === this.DONE) {
        const response = JSON.parse(this.responseText);
        const output = response.choices[0].message.content;
        resolve(output);
      }
    });

    xhr.open("POST", url);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.setRequestHeader("

--------------------------
continue
--------------------------
Authorization", "Bearer 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");
xhr.send(data);
});
}

async function translateAll() {
const input = document.getElementById("input").value;
const chunks = splitText(input);
const outputContainer = document.getElementById("output");
const finalOutputContainer = document.getElementById("final-output");

outputContainer.innerHTML = '';
finalOutputContainer.innerHTML = '';

for (let i = 0; i < chunks.length; i++) {
const chunk = chunks[i];
const inputChunkElement = document.createElement('div');
inputChunkElement.className = 'input-chunk';
inputChunkElement.innerHTML = '<p>' + chunk + '</p>';
outputContainer.appendChild(inputChunkElement);

javascript
Copy code
const outputChunkElement = document.createElement('div');
outputChunkElement.className = 'output-chunk';

try {
  const output = await translateChunk(chunk);
  outputChunkElement.innerHTML = '<p>' + output + '</p>';
} catch (error) {
  outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
}

outputContainer.appendChild(outputChunkElement);
finalOutputContainer.innerHTML += output + '\n';
await new Promise(resolve => setTimeout(resolve, 3000));


}
}

css
Copy code

Now we have separated the HTML, CSS, and JavaScript files to make the code more maintainable and easier to understand. The HTML file (index.html) contains the structure, the CSS file (styles.css) contains the styles, and the JavaScript file (translator.js) contains the functionality.

--------------------------
I will paste a javascript file, you need to clean up the code to follow good programming principles such as DRY, SOLID, KISS, and any other properties that make up good software. Make sure there are no magic numbers and unnamed constant values.

document.getElementById("translate-button").addEventListener("click", translateAll);

function splitText(text) {
    const replaced = text.replace(/\r\n/g, ".\n\n");
    const paragraphs = replaced.split(/.\n\n/);
    const chunks = [];
    let chunk = '';

    paragraphs.forEach(paragraph => {
        if (chunk.length + paragraph.length > 850) {
            chunks.push(chunk);
            chunk = '';
        }
        chunk += paragraph + '\n\n';
    });

    if (chunk.trim().length > 1) {
        chunks.push(chunk);
    }

    return chunks;
}

function translateChunk(chunk) {
    return new Promise((resolve, reject) => {
        const url = "https://api.openai.com/v1/chat/completions";
        const data = JSON.stringify({
            model: "gpt-3.5-turbo",
            messages: [{ "role": "user", "content": "translate to English: " + chunk }]
        });
        const xhr = new XMLHttpRequest();

        xhr.addEventListener("readystatechange", function () {
            if (this.readyState === this.DONE) {
                const response = JSON.parse(this.responseText);
                const output = response.choices[0].message.content;
                resolve(output);
            }
        });

        xhr.open("POST", url);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader("Authorization", "Bearer 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");
        xhr.send(data);
    });
}

async function translateAll() {
    const input = document.getElementById("input").value;
    const chunks = splitText(input);
    const outputContainer = document.getElementById("output");
    const finalOutputContainer = document.getElementById("final-output");

    outputContainer.innerHTML = '';
    finalOutputContainer.innerHTML = '';

    for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i];
        const inputChunkElement = document.createElement('div');
        inputChunkElement.className = 'input-chunk';
        inputChunkElement.innerHTML = '<p>' + chunk + '</p>';
        outputContainer.appendChild(inputChunkElement);
        const outputChunkElement = document.createElement('div');
        outputChunkElement.className = 'output-chunk';

        try {
            const output = await translateChunk(chunk);
            outputChunkElement.innerHTML = '<p>' + output + '</p>';
        } catch (error) {
            outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
        }

        outputContainer.appendChild(outputChunkElement);
        finalOutputContainer.innerHTML += output + '\n';
        await new Promise(resolve => setTimeout(resolve, 3000));
    }
}

--------------------------
Here is the refactored JavaScript code, adhering to good programming principles:

javascript
Copy code
const MAX_CHUNK_SIZE = 850;
const API_URL = "https://api.openai.com/v1/chat/completions";
const API_KEY = "Bearer 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";
const TRANSLATE_DELAY = 3000;

document.getElementById("translate-button").addEventListener("click", translateAll);

function splitText(text) {
    const replaced = text.replace(/\r\n/g, ".\n\n");
    const paragraphs = replaced.split(/.\n\n/);
    const chunks = [];
    let chunk = '';

    paragraphs.forEach(paragraph => {
        if (chunk.length + paragraph.length > MAX_CHUNK_SIZE) {
            chunks.push(chunk);
            chunk = '';
        }
        chunk += paragraph + '\n\n';
    });

    if (chunk.trim().length > 1) {
        chunks.push(chunk);
    }

    return chunks;
}

function translateChunk(chunk) {
    return new Promise((resolve, reject) => {
        const data = JSON.stringify({
            model: "gpt-3.5-turbo",
            messages: [{ "role": "user", "content": "translate to English: " + chunk }]
        });
        const xhr = new XMLHttpRequest();

        xhr.addEventListener("readystatechange", function () {
            if (this.readyState === this.DONE) {
                const response = JSON.parse(this.responseText);
                const output = response.choices[0].message.content;
                resolve(output);
            }
        });

        xhr.open("POST", API_URL);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader("Authorization", API_KEY);
        xhr.send(data);
    });
}

async function translateAll() {
    const input = document.getElementById("input").value;
    const chunks = splitText(input);
    const outputContainer = document.getElementById("output");
    const finalOutputContainer = document.getElementById("final-output");

    outputContainer.innerHTML = '';
    finalOutputContainer.innerHTML = '';

    for (let chunk of chunks) {
        const inputChunkElement = createChunkElement(chunk, 'input-chunk');
        outputContainer.appendChild(inputChunkElement);

        const outputChunkElement = document.createElement('div');
        outputChunkElement.className = 'output-chunk';

        try {
            const output = await translateChunk(chunk);
            outputChunkElement.innerHTML = '<p>' + output + '</p>';
        } catch (error) {
            outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
        }

        outputContainer.appendChild(outputChunkElement);
        finalOutputContainer.innerHTML += output + '\n';
        await delay(TRANSLATE_DELAY);
    }
}

function createChunkElement(chunk, className) {
    const chunkElement = document.createElement('div');
    chunkElement.className = className;
    chunkElement.innerHTML = '<p>' + chunk + '</p>';
    return chunkElement;
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}


The code has been cleaned up to follow good programming principles:

Constants are defined at the beginning of the code, removing magic numbers and unnamed constant values.
The translateAll() function has been simplified using a for...of loop.
A separate createChunkElement() function has been created to adhere to the Single Responsibility Principle (SRP) and to make the code more readable.
A delay() function has been added to make the code more readable and to avoid using anonymous functions.
--------------------------
2 / 2
I am going to paste html and css code for a webpage. The webpage consists of a text box to input text, underneath that there is a section where two chunks of text are displayed side by side. the text on the left is untranslated text, and the text on the right is translated text. There can be several pairs of these text chunks. After the text chunks there is a section for the final translated output. I want you to modify the styling of this page to look more modern and sleek. Each section should stand out, and each pair of text chunks in the 2nd section should be separate from other pairs. Choose appropriate colours, font sizes, margins, and styles to make the web page look visually pleasing. It should also be responsive and look good on mobile devices, as well as desktop devices. Give me an html file and a css file separately.

input html file:
<!DOCTYPE html>
<html>

<head>
    <title>ChatGPT English Translator</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <script src="translator.js" defer></script>
</head>

<body>
    <h1>ChatGPT English Translator</h1>
    <label for="input">Input Text:</label>
    <br>
    <textarea id="input" name="input"></textarea>
    <br>
    <button id="translate-button">Translate</button>
    <br>
    <h2>Translated Chunks:</h2>
    <div id="output"></div>
    <h2>Final Translated Output:</h2>
    <div id="final-output"></div>
</body>

</html>


input css file:
body {
    font-family: Arial, sans-serif;
}

#input {
    width: 100%;
    height: 50px;
    font-size: 16px;
    padding: 10px;
    box-sizing: border-box;
    border: 2px solid #ccc;
    border-radius: 4px;
    margin-bottom: 10px;
}

#output {
    display: flex;
    flex-wrap: wrap;
}

.input-chunk,
.output-chunk {
    width: 50%;
    padding: 10px;
    box-sizing: border-box;
    white-space: pre-wrap;
    border: 1px solid red;
    margin-bottom: 10px;
}

.input-chunk {
    background-color: #f2f2f2;
    border-top: 1px solid green;
}

button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

button:hover {
    background-color: #45a049;
}

#final-output {
    white-space: pre-wrap;
}
--------------------------
Here is the updated HTML and CSS code for a more modern and sleek design. The design is also responsive and should look good on both mobile and desktop devices.

Updated HTML file:

html
Copy code
<!DOCTYPE html>
<html>

<head>
    <title>ChatGPT English Translator</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <script src="translator.js" defer></script>
</head>

<body>
    <header>
        <h1>ChatGPT English Translator</h1>
    </header>
    <main>
        <section class="input-section">
            <label for="input">Input Text:</label>
            <textarea id="input" name="input"></textarea>
            <button id="translate-button">Translate</button>
        </section>
        <section class="chunks-section">
            <h2>Translated Chunks:</h2>
            <div id="output"></div>
        </section>
        <section class="final-output-section">
            <h2>Final Translated Output:</h2>
            <div id="final-output"></div>
        </section>
    </main>
</body>

</html>


Updated CSS file:

css
Copy code
body {
    font-family: 'Roboto', sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 0;
    color: #333;
    background-color: #f5f5f5;
}

header {
    background-color: #3f51b5;
    padding: 1rem;
}

header h1 {
    color: white;
    margin: 0;
}

main {
    max-width: 1200px;
    margin: 2rem auto;
    padding: 0 2rem;
}

.input-section {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

#input {
    width: 100%;
    height: 150px;
    font-size: 16px;
    padding: 10px;
    box-sizing: border-box;
    border: 2px solid #ccc;
    border-radius: 4px;
    resize: vertical;
}

button {
    align-self: flex-start;
    background-color: #3f51b5;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
}

button:hover {
    background-color: #283593;
}

.chunks-section {
    margin-top: 2rem;
}

.input-chunk,
.output-chunk {
    flex: 0 0 calc(50% - 1rem);
    padding: 1rem;
    box-sizing: border-box;
    white-space: pre-wrap;
    background-color: white;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
    border-radius: 4px;
    margin-bottom: 1rem;
}

.input-chunk {
    margin-right: 1rem;
}

.final-output-section {
    margin-top: 2rem;
    padding: 1rem;
    background-color: white;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(

--------------------------
continue the output for the css file
--------------------------
I apologize for the incomplete CSS code. Here's the continuation of the CSS file:

css
Copy code
0, 0, 0, 0.24);
    border-radius: 4px;
}

#final-output {
    white-space: pre-wrap;
}

/* Media Queries for Responsiveness */
@media (max-width: 768px) {
    .input-chunk,
    .output-chunk {
        flex: 0 0 100%;
    }
    
    .input-chunk {
        margin-right: 0;
        margin-bottom: 1rem;
    }
}


This CSS code should provide a more modern and sleek look for your webpage, as well as making it responsive for mobile and desktop devices.
--------------------------
I want you to edit the css style of the chunks section and input and output chunk so that the pair of input and output chunks are side by side. that is, one input chunk on the left, and the corresponding output chunk on the right.
--------------------------
Certainly! Here's the updated CSS code that positions the input and output chunks side by side:

css
Copy code
body {
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

h1, h2 {
    margin-bottom: 1rem;
}

#input {
    width: 100%;
    height: 150px;
    font-size: 16px;
    padding: 10px;
    box-sizing: border-box;
    border: 2px solid #ccc;
    border-radius: 4px;
    margin-bottom: 10px;
}

#output {
    display: flex;
    flex-wrap: wrap;
}

.input-chunk,
.output-chunk {
    padding: 10px;
    box-sizing: border-box;
    white-space: pre-wrap;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

.input-chunk {
    width: calc(50% - 10px);
    margin-right: 10px;
}

.output-chunk {
    width: 50%;
}

button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

button:hover {
    background-color: #45a049;
}

#final-output {
    white-space: pre-wrap;
    padding: 10px;
    box-sizing: border-box;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

/* Media Queries for Responsiveness */
@media (max-width: 768px) {
    .input-chunk {
        width: 100%;
        margin-right: 0;
        margin-bottom: 1rem;
    }

    .output-chunk {
        width: 100%;
    }
}


This code adjusts the input and output chunks to display side by side, with the input chunk on the left and the output chunk on the right. It also makes the layout responsive for mobile devices.
--------------------------
2 / 2
I am going to copy paste the html, css, and javascript files for a website that translate text to english using chat gpt. I want you to make the following changes to the website, while maintaining the properties of the website and code.

1. add a "cancel translation" button beside the "translate" button. When user clicks this button, any translation in progress should be cancelled.
2. When a text chunk is currently being translated, the output column doesn't display anything. I want you to display a spinning circle on the output chunk column to indicate that it is currently loading.
3. I want you to add another section and input box at the top of the screen for users to input their API_KEY. This api key will be used in place of the existing API_KEY

input html:
<!DOCTYPE html>
<html>

<head>
    <title>ChatGPT English Translator</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <script src="translator.js" defer></script>
</head>

<body>
    <header>
        <h1>ChatGPT English Translator</h1>
    </header>
    <main>
        <section class="input-section">
            <label for="input">Input Text:</label>
            <textarea id="input" name="input"></textarea>
            <button id="translate-button">Translate</button>
        </section>
        <section class="chunks-section">
            <h2>Translated Chunks:</h2>
            <div id="output"></div>
        </section>
        <section class="final-output-section">
            <h2>Final Translated Output:</h2>
            <div id="final-output"></div>
        </section>
    </main>
</body>

</html>

input css:
body {
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

h1, h2 {
    margin-bottom: 1rem;
}

#input {
    width: 100%;
    height: 150px;
    font-size: 16px;
    padding: 10px;
    box-sizing: border-box;
    border: 2px solid #ccc;
    border-radius: 4px;
    margin-bottom: 10px;
}

#output {
    display: flex;
    flex-wrap: wrap;
}

.input-chunk,
.output-chunk {
    padding: 10px;
    box-sizing: border-box;
    white-space: pre-wrap;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

.input-chunk {
    width: calc(50% - 10px);
    margin-right: 10px;
}

.output-chunk {
    width: 50%;
}

button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

button:hover {
    background-color: #45a049;
}

#final-output {
    white-space: pre-wrap;
    padding: 10px;
    box-sizing: border-box;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

/* Media Queries for Responsiveness */
@media (max-width: 768px) {
    .input-chunk {
        width: 100%;
        margin-right: 0;
        margin-bottom: 1rem;
    }

    .output-chunk {
        width: 100%;
    }
}


input javascript:
const MAX_CHUNK_SIZE = 850;
const API_URL = "https://api.openai.com/v1/chat/completions";
const API_KEY = "Bearer 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";
const TRANSLATE_DELAY = 3000;

document.getElementById("translate-button").addEventListener("click", translateAll);

function splitText(text) {
    const replaced = text.replace(/\r\n/g, ".\n\n");
    const paragraphs = replaced.split(/.\n\n/);
    const chunks = [];
    let chunk = '';

    paragraphs.forEach(paragraph => {
        if (chunk.length + paragraph.length > MAX_CHUNK_SIZE) {
            chunks.push(chunk);
            chunk = '';
        }
        chunk += paragraph + '\n\n';
    });

    if (chunk.trim().length > 1) {
        chunks.push(chunk);
    }

    return chunks;
}

function translateChunk(chunk) {
    return new Promise((resolve, reject) => {
        const data = JSON.stringify({
            model: "gpt-3.5-turbo",
            messages: [{ "role": "user", "content": "translate to English: " + chunk }]
        });
        const xhr = new XMLHttpRequest();

        xhr.addEventListener("readystatechange", function () {
            if (this.readyState === this.DONE) {
                const response = JSON.parse(this.responseText);
                const output = response.choices[0].message.content;
                resolve(output);
            }
        });

        xhr.open("POST", API_URL);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader("Authorization", API_KEY);
        xhr.send(data);
    });
}

async function translateAll() {
    const input = document.getElementById("input").value;
    const chunks = splitText(input);
    const outputContainer = document.getElementById("output");
    const finalOutputContainer = document.getElementById("final-output");

    outputContainer.innerHTML = '';
    finalOutputContainer.innerHTML = '';

    for (let chunk of chunks) {
        const inputChunkElement = createChunkElement(chunk, 'input-chunk');
        outputContainer.appendChild(inputChunkElement);

        const outputChunkElement = document.createElement('div');
        outputChunkElement.className = 'output-chunk';

        let output
        try {
            output = await translateChunk(chunk);
            outputChunkElement.innerHTML = '<p>' + output + '</p>';
        } catch (error) {
            outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
        }

        outputContainer.appendChild(outputChunkElement);
        finalOutputContainer.innerHTML += output + '\n';
        await delay(TRANSLATE_DELAY);
    }
}

function createChunkElement(chunk, className) {
    const chunkElement = document.createElement('div');
    chunkElement.className = className;
    chunkElement.innerHTML = '<p>' + chunk + '</p>';
    return chunkElement;
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}




--------------------------
I have made the requested changes to the HTML, CSS, and JavaScript files. Please find the updated code below.

Updated HTML file:

html
Copy code
<!DOCTYPE html>
<html>

<head>
    <title>ChatGPT English Translator</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <script src="translator.js" defer></script>
</head>

<body>
    <header>
        <h1>ChatGPT English Translator</h1>
    </header>
    <main>
        <section class="api-key-section">
            <label for="api-key">API Key:</label>
            <input type="text" id="api-key" name="api-key" placeholder="Enter your API Key">
        </section>
        <section class="input-section">
            <label for="input">Input Text:</label>
            <textarea id="input" name="input"></textarea>
            <button id="translate-button">Translate</button>
            <button id="cancel-translate-button">Cancel Translation</button>
        </section>
        <section class="chunks-section">
            <h2>Translated Chunks:</h2>
            <div id="output"></div>
        </section>
        <section class="final-output-section">
            <h2>Final Translated Output:</h2>
            <div id="final-output"></div>
        </section>
    </main>
</body>

</html>


Updated CSS file:

css
Copy code
body {
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

h1, h2 {
    margin-bottom: 1rem;
}

input {
    width: 100%;
    font-size: 16px;
    padding: 10px;
    box-sizing: border-box;
    border: 2px solid #ccc;
    border-radius: 4px;
    margin-bottom: 10px;
}

#input {
    width: 100%;
    height: 150px;
}

#output {
    display: flex;
    flex-wrap: wrap;
}

.input-chunk,
.output-chunk {
    padding: 10px;
    box-sizing: border-box;
    white-space: pre-wrap;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

.input-chunk {
    width: calc(50% - 10px);
    margin-right: 10px;
}

.output-chunk {
    width: 50%;
}

button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 10px;
}

button:hover {
    background-color: #45a049;
}

#cancel-translate-button {
    background-color: #f44336;
}

#cancel-translate-button:hover {
    background-color: #e53935;
}

#final-output {
    white-space: pre-wrap;
    padding: 10px;
    box-sizing: border-box;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

.loader {
    border: 4px solid #f3f3f3;
    border-radius: 50%;
    border-top: 4px solid #349

--------------------------
continue the output of the css and javascript files which are currently not complete
--------------------------
Apologies for the incomplete code. Here's the continuation of the CSS and JavaScript files.

Continued CSS file:

css
Copy code
.loader {
    border: 4px solid #f3f3f3;
    border-radius: 50%;
    border-top: 4px solid #3498db;
    width: 24px;
    height: 24px;
    animation: spin 2s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Media Queries for Responsiveness */
@media (max-width: 768px) {
    .input-chunk {
        width: 100%;
        margin-right: 0;
        margin-bottom: 1rem;
    }

    .output-chunk {
        width: 100%;
    }
}


Continued JavaScript file:

javascript
Copy code
const MAX_CHUNK_SIZE = 850;
const API_URL = "https://api.openai.com/v1/chat/completions";
const TRANSLATE_DELAY = 3000;
let cancelTranslation = false;

document.getElementById("translate-button").addEventListener("click", translateAll);
document.getElementById("cancel-translate-button").addEventListener("click", cancelCurrentTranslation);

function getAPIKey() {
    return document.getElementById("api-key").value;
}

function splitText(text) {
    // ...
}

function translateChunk(chunk, apiKey) {
    return new Promise((resolve, reject) => {
        if (!apiKey) {
            reject(new Error('API Key is required'));
            return;
        }

        const data = JSON.stringify({
            // ...
        });

        const xhr = new XMLHttpRequest();

        xhr.addEventListener("readystatechange", function () {
            // ...
        });

        xhr.open("POST", API_URL);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader("Authorization", `Bearer ${apiKey}`);
        xhr.send(data);
    });
}

async function translateAll() {
    cancelTranslation = false;
    const input = document.getElementById("input").value;
    const chunks = splitText(input);
    const outputContainer = document.getElementById("output");
    const finalOutputContainer = document.getElementById("final-output");
    const apiKey = getAPIKey();

    outputContainer.innerHTML = '';
    finalOutputContainer.innerHTML = '';

    for (let chunk of chunks) {
        // ...

        let output
        try {
            output = await translateChunk(chunk, apiKey);
            outputChunkElement.innerHTML = '<p>' + output + '</p>';
        } catch (error) {
            outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
        }

        if (cancelTranslation) {
            outputContainer.innerHTML = '';
            finalOutputContainer.innerHTML = '';
            cancelTranslation = false;
            break;
        }

        // ...
    }
}

function createChunkElement(chunk, className) {
    // ...
}

function createLoaderElement() {
    const loaderElement = document.createElement('div');
    loaderElement.className = 'loader';
    return loaderElement;
}

function cancelCurrentTranslation() {
    cancelTranslation = true;
}

function delay(ms) {
    // ...
}


These updated files include the "Cancel Translation" button, a spinning loader for the output chunk, and the API Key input field.
--------------------------
modify the javascript to do the following: when the number of characters in the translated result is less than 60% the number of characters in the untranslated text, redo the translation.
--------------------------
Here is the modified JavaScript file to redo the translation if the number of characters in the translated result is less than 60% of the number of characters in the untranslated text:

javascript
Copy code
async function translateAll() {
    cancelTranslation = false;
    const input = document.getElementById("input").value;
    const chunks = splitText(input);
    const outputContainer = document.getElementById("output");
    const finalOutputContainer = document.getElementById("final-output");
    const apiKey = getAPIKey();

    outputContainer.innerHTML = '';
    finalOutputContainer.innerHTML = '';

    for (let chunk of chunks) {
        const inputChunkElement = createChunkElement(chunk, 'input-chunk');
        outputContainer.appendChild(inputChunkElement);

        const outputChunkElement = document.createElement('div');
        outputChunkElement.className = 'output-chunk';
        outputChunkElement.appendChild(createLoaderElement());

        let output;
        let translationAttempts = 0;

        while (translationAttempts < 3) {
            try {
                output = await translateChunk(chunk, apiKey);

                if (output.length >= chunk.length * 0.6) {
                    outputChunkElement.innerHTML = '<p>' + output + '</p>';
                    break;
                } else {
                    translationAttempts += 1;
                }
            } catch (error) {
                outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
                break;
            }
        }

        if (cancelTranslation) {
            outputContainer.innerHTML = '';
            finalOutputContainer.innerHTML = '';
            cancelTranslation = false;
            break;
        }

        outputContainer.appendChild(outputChunkElement);
        finalOutputContainer.innerHTML += output + '\n';
        await delay(TRANSLATE_DELAY);
    }
}


The translateAll function now includes a while loop with a maximum of three translation attempts. If the translated result's length is less than 60% of the untranslated text's length, it will try to translate the chunk again until it meets the condition or reaches the maximum number of attempts.
--------------------------
modify the javascript so that when the translation is cancelled, user is notified with an alert box stating the translation has been cancelled.
--------------------------
Here's the modified JavaScript file with the addition of an alert box notifying the user that the translation has been cancelled:

javascript
Copy code
async function translateAll() {
    cancelTranslation = false;
    const input = document.getElementById("input").value;
    const chunks = splitText(input);
    const outputContainer = document.getElementById("output");
    const finalOutputContainer = document.getElementById("final-output");
    const apiKey = getAPIKey();

    outputContainer.innerHTML = '';
    finalOutputContainer.innerHTML = '';

    for (let chunk of chunks) {
        const inputChunkElement = createChunkElement(chunk, 'input-chunk');
        outputContainer.appendChild(inputChunkElement);

        const outputChunkElement = document.createElement('div');
        outputChunkElement.className = 'output-chunk';
        outputChunkElement.appendChild(createLoaderElement());

        let output;
        let translationAttempts = 0;

        while (translationAttempts < 3) {
            try {
                output = await translateChunk(chunk, apiKey);

                if (output.length >= chunk.length * 0.6) {
                    outputChunkElement.innerHTML = '<p>' + output + '</p>';
                    break;
                } else {
                    translationAttempts += 1;
                }
            } catch (error) {
                outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
                break;
            }
        }

        if (cancelTranslation) {
            outputContainer.innerHTML = '';
            finalOutputContainer.innerHTML = '';
            cancelTranslation = false;
            alert("Translation has been cancelled.");
            break;
        }

        outputContainer.appendChild(outputChunkElement);
        finalOutputContainer.innerHTML += output + '\n';
        await delay(TRANSLATE_DELAY);
    }
}


Now, when the translation is cancelled, the user will see an alert box stating that the translation has been cancelled.
--------------------------
2 / 2
I am going to copy paste the html, css, and javascript files for a website that translate text to english using chat gpt. When a text chunk is translated, the raw untranslated text is displayed in the left, and the translated text is displayed on the right. I want you to make the following changes to the website, while maintaining the properties of the website and code.

1. While text is in the middle of being translated, on the right side instead of displaying nothing, display the message "Translation in progress..." along with a spinning loading circle to indicate the text is translating. Once the text is translated, display the translated text instead of the loading message. 

input html file:

<!DOCTYPE html>
<html>

<head>
    <title>ChatGPT English Translator</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <script src="translator.js" defer></script>
</head>

<body>
    <header>
        <h1>ChatGPT English Translator</h1>
    </header>
    <main>
        <section class="api-key-section">
            <label for="api-key">API Key:</label>
            <input type="text" id="api-key" name="api-key" placeholder="Enter your API Key">
        </section>
        <section class="input-section">
            <label for="input">Input Text:</label>
            <textarea id="input" name="input"></textarea>
            <button id="translate-button">Translate</button>
            <button id="cancel-translate-button">Cancel Translation</button>
        </section>
        <section class="chunks-section">
            <h2>Translated Chunks:</h2>
            <div id="output"></div>
        </section>
        <section class="final-output-section">
            <h2>Final Translated Output:</h2>
            <div id="final-output"></div>
        </section>
    </main>
</body>

</html>


input css file:
body {
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

h1, h2 {
    margin-bottom: 1rem;
}

input {
    width: 100%;
    font-size: 16px;
    padding: 10px;
    box-sizing: border-box;
    border: 2px solid #ccc;
    border-radius: 4px;
    margin-bottom: 10px;
}

#input {
    width: 100%;
    height: 150px;
}

#output {
    display: flex;
    flex-wrap: wrap;
}

.input-chunk,
.output-chunk {
    padding: 10px;
    box-sizing: border-box;
    white-space: pre-wrap;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

.input-chunk {
    width: calc(50% - 10px);
    margin-right: 10px;
}

.output-chunk {
    width: 50%;
}

button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 10px;
}

button:hover {
    background-color: #45a049;
}

#cancel-translate-button {
    background-color: #f44336;
}

#cancel-translate-button:hover {
    background-color: #e53935;
}

#final-output {
    white-space: pre-wrap;
    padding: 10px;
    box-sizing: border-box;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

.loader {
    border: 4px solid #f3f3f3;
    border-radius: 50%;
    border-top: 4px solid #3498db;
    width: 24px;
    height: 24px;
    animation: spin 2s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Media Queries for Responsiveness */
@media (max-width: 768px) {
    .input-chunk {
        width: 100%;
        margin-right: 0;
        margin-bottom: 1rem;
    }

    .output-chunk {
        width: 100%;
    }
}

input javascript file:

const MAX_CHUNK_SIZE = 800;
const API_URL = "https://api.openai.com/v1/chat/completions";
const TRANSLATE_DELAY = 3500;
const TRANSLATION_RETRIES = 3;
const TRANSLATED_TEXT_REQUIRED_SIZE_RATIO = 0.6;
let cancelTranslation = false;

document.getElementById("translate-button").addEventListener("click", translateAll);
document.getElementById("cancel-translate-button").addEventListener("click", cancelCurrentTranslation);

function getAPIKey() {
    return document.getElementById("api-key").value;
}

function splitText(text) {
    const replaced = text.replace(/\r\n/g, ".\n\n");
    const paragraphs = replaced.split(/.\n\n/);
    const chunks = [];
    let chunk = '';

    paragraphs.forEach(paragraph => {
        if (chunk.length + paragraph.length > MAX_CHUNK_SIZE) {
            chunks.push(chunk);
            chunk = '';
        }
        chunk += paragraph + '\n\n';
    });

    if (chunk.trim().length > 1) {
        chunks.push(chunk);
    }

    return chunks;
}

function translateChunk(chunk, apiKey) {
    return new Promise((resolve, reject) => {
        if (!apiKey) {
            reject(new Error('API Key is required'));
            return;
        }

        const data = JSON.stringify({
            model: "gpt-3.5-turbo",
            messages: [{ "role": "user", "content": "translate directly to English. Don't Summarize or shorten the final result. Provide an exact translation only: " + chunk }]
        });

        const xhr = new XMLHttpRequest();

        xhr.addEventListener("readystatechange", function () {
            if (this.readyState === this.DONE) {
                const response = JSON.parse(this.responseText);
                const output = response.choices[0].message.content;
                resolve(output);
            }
        });

        xhr.open("POST", API_URL);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader("Authorization", `Bearer ${apiKey}`);
        xhr.send(data);
    });
}

async function translateAll() {
    cancelTranslation = false;
    const input = document.getElementById("input").value;
    const chunks = splitText(input);
    const outputContainer = document.getElementById("output");
    const finalOutputContainer = document.getElementById("final-output");
    const apiKey = getAPIKey();

    outputContainer.innerHTML = '';
    finalOutputContainer.innerHTML = '';

    for (let chunk of chunks) {
        const inputChunkElement = createChunkElement(chunk, 'input-chunk');
        outputContainer.appendChild(inputChunkElement);

        const outputChunkElement = document.createElement('div');
        outputChunkElement.className = 'output-chunk';
        outputChunkElement.appendChild(createLoaderElement());

        let output;
        let translationAttempts = 0;

        while (translationAttempts < TRANSLATION_RETRIES) {
            try {
                output = await translateChunk(chunk, apiKey);

                if (output.length >= chunk.length * TRANSLATED_TEXT_REQUIRED_SIZE_RATIO) {
                    outputChunkElement.innerHTML = '<p>' + output + '</p>';
                    break;
                } else {
                    translationAttempts += 1;
                }
            } catch (error) {
                outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
                break;
            }
        }

        if (cancelTranslation) {
            cancelTranslation = false;
            break;
        }

        outputContainer.appendChild(outputChunkElement);
        finalOutputContainer.innerHTML += output + '\n';
        await delay(TRANSLATE_DELAY);
    }
}

function createChunkElement(chunk, className) {
    const chunkElement = document.createElement('div');
    chunkElement.className = className;
    chunkElement.innerHTML = '<p>' + chunk + '</p>';
    return chunkElement;
}

function createLoaderElement() {
    const loaderElement = document.createElement('div');
    loaderElement.className = 'loader';
    return loaderElement;
}

function cancelCurrentTranslation() {
    cancelTranslation = true;
    alert("Translation has been cancelled.");
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

--------------------------
Here are the modified HTML, CSS, and JavaScript files, incorporating your requested changes.

Modified HTML file:

html
Copy code
<!DOCTYPE html>
<html>

<head>
    <title>ChatGPT English Translator</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <script src="translator.js" defer></script>
</head>

<body>
    <header>
        <h1>ChatGPT English Translator</h1>
    </header>
    <main>
        <section class="api-key-section">
            <label for="api-key">API Key:</label>
            <input type="text" id="api-key" name="api-key" placeholder="Enter your API Key">
        </section>
        <section class="input-section">
            <label for="input">Input Text:</label>
            <textarea id="input" name="input"></textarea>
            <button id="translate-button">Translate</button>
            <button id="cancel-translate-button">Cancel Translation</button>
        </section>
        <section class="chunks-section">
            <h2>Translated Chunks:</h2>
            <div id="output"></div>
        </section>
        <section class="final-output-section">
            <h2>Final Translated Output:</h2>
            <div id="final-output"></div>
        </section>
    </main>
</body>

</html>


Modified CSS file:

css
Copy code
body {
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

h1, h2 {
    margin-bottom: 1rem;
}

input {
    width: 100%;
    font-size: 16px;
    padding: 10px;
    box-sizing: border-box;
    border: 2px solid #ccc;
    border-radius: 4px;
    margin-bottom: 10px;
}

#input {
    width: 100%;
    height: 150px;
}

#output {
    display: flex;
    flex-wrap: wrap;
}

.input-chunk,
.output-chunk {
    padding: 10px;
    box-sizing: border-box;
    white-space: pre-wrap;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

.input-chunk {
    width: calc(50% - 10px);
    margin-right: 10px;
}

.output-chunk {
    width: 50%;
}

button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 10px;
}

button:hover {
    background-color: #45a049;
}

#cancel-translate-button {
    background-color: #f44336;
}

#cancel-translate-button:hover {
    background-color: #e53935;
}

#final-output {
    white-space: pre-wrap;
    padding: 10px;
    box-sizing: border-box;
    border: 1px solid #ccc;
    margin-bottom: 20px;
    border-radius: 4px;
    background-color: #ffffff;
}

.loader {
    border: 4px solid #f3f3f3;
    border-radius: 50%;
    border-top: 4px solid #3498db;
    width:

--------------------------
output the rest of the css and javascript files
--------------------------
Apologies for the incomplete response. Here are the rest of the CSS and JavaScript files:

Modified CSS file:

css
Copy code
    width: 24px;
    height: 24px;
    animation: spin 2s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Media Queries for Responsiveness */
@media (max-width: 768px) {
    .input-chunk {
        width: 100%;
        margin-right: 0;
        margin-bottom: 1rem;
    }

    .output-chunk {
        width: 100%;
    }
}


Modified JavaScript file:

javascript
Copy code
const MAX_CHUNK_SIZE = 800;
const API_URL = "https://api.openai.com/v1/chat/completions";
const TRANSLATE_DELAY = 3500;
const TRANSLATION_RETRIES = 3;
const TRANSLATED_TEXT_REQUIRED_SIZE_RATIO = 0.6;
let cancelTranslation = false;

document.getElementById("translate-button").addEventListener("click", translateAll);
document.getElementById("cancel-translate-button").addEventListener("click", cancelCurrentTranslation);

function getAPIKey() {
    return document.getElementById("api-key").value;
}

function splitText(text) {
    const replaced = text.replace(/\r\n/g, ".\n\n");
    const paragraphs = replaced.split(/.\n\n/);
    const chunks = [];
    let chunk = '';

    paragraphs.forEach(paragraph => {
        if (chunk.length + paragraph.length > MAX_CHUNK_SIZE) {
            chunks.push(chunk);
            chunk = '';
        }
        chunk += paragraph + '\n\n';
    });

    if (chunk.trim().length > 1) {
        chunks.push(chunk);
    }

    return chunks;
}

function translateChunk(chunk, apiKey) {
    return new Promise((resolve, reject) => {
        if (!apiKey) {
            reject(new Error('API Key is required'));
            return;
        }

        const data = JSON.stringify({
            model: "gpt-3.5-turbo",
            messages: [{ "role": "user", "content": "translate directly to English. Don't Summarize or shorten the final result. Provide an exact translation only: " + chunk }]
        });

        const xhr = new XMLHttpRequest();

        xhr.addEventListener("readystatechange", function () {
            if (this.readyState === this.DONE) {
                const response = JSON.parse(this.responseText);
                const output = response.choices[0].message.content;
                resolve(output);
            }
        });

        xhr.open("POST", API_URL);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader("Authorization", `Bearer ${apiKey}`);
        xhr.send(data);
    });
}

async function translateAll() {
    cancelTranslation = false;
    const input = document.getElementById("input").value;
    const chunks = splitText(input);
    const outputContainer = document.getElementById("output");
    const finalOutputContainer = document.getElementById("final-output");
    const apiKey = getAPIKey();

    outputContainer.innerHTML = '';
    finalOutputContainer.innerHTML = '';

    for (let chunk of chunks) {
        const inputChunkElement = createChunkElement(chunk, 'input-chunk');
        outputContainer.appendChild(inputChunkElement);

        const outputChunkElement = document.createElement('div');
        outputChunkElement.className = 'output-chunk';
        outputChunkElement.innerHTML = '<p>Translation in progress...</p>';
        outputChunkElement.appendChild(createLoaderElement());

        outputContainer.appendChild(outputChunkElement);

        let output;
        let translationAttempts = 0;

        while (translationAttempts < TRANSLATION_RETRIES) {
            try

--------------------------
continue the output of the javascript file
--------------------------
I apologize for the truncation. Here's the continuation of the JavaScript file:

javascript
Copy code
                output = await translateChunk(chunk, apiKey);

                if (output.length >= chunk.length * TRANSLATED_TEXT_REQUIRED_SIZE_RATIO) {
                    outputChunkElement.innerHTML = '<p>' + output + '</p>';
                    break;
                } else {
                    translationAttempts += 1;
                }
            } catch (error) {
                outputChunkElement.innerHTML = '<p>Error: ' + error.message + '</p>';
                break;
            }
        }

        if (cancelTranslation) {
            cancelTranslation = false;
            break;
        }

        finalOutputContainer.innerHTML += output + '\n';
        await delay(TRANSLATE_DELAY);
    }
}

function createChunkElement(chunk, className) {
    const chunkElement = document.createElement('div');
    chunkElement.className = className;
    chunkElement.innerHTML = '<p>' + chunk + '</p>';
    return chunkElement;
}

function createLoaderElement() {
    const loaderElement = document.createElement('div');
    loaderElement.className = 'loader';
    return loaderElement;
}

function cancelCurrentTranslation() {
    cancelTranslation = true;
    alert("Translation has been cancelled.");
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}


With these modifications to the JavaScript file, the website should now display the "Translation in progress..." message along with a spinning loading circle on the right side while the text is being translated. Once the text is translated, the translated text will be displayed instead of the loading message.